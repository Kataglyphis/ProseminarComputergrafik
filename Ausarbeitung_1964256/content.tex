%% content.tex
%%

%% ==============================

\chapter{Abstract}

In unser heutigen hoch technologisierten Welt steigt stetig und rasant die Leistungsfähigkeit moderner Grafikhardware.
Um heutzutage Grafik auf einem modernen Computer darzustellen sind mittlerweile eine Vielzahl von Zwischenschritten nötig.
Diese Arbeit beschäftigt sich um die einzelnen Stufen dieser Kette, deren jeweilige Aufgabe, ihren Datentransfer untereinander,
ihre Reihenfolge sowie ihren Arbeitskontext. Beim Arbeitskontext werden unter anderem die unterschiedlichen Koordinatensysteme untersucht. 
Dabei soll nicht nur konkret auf die Arbeitsweise der einzelnen Stufe eingegangen werden, sondern auch im Speziellen auf die Zusammenarbeit und Kommunikation. 
Exemplarische Fragestellungen die behandelt werden sind Folgende: Können in dieser Art der Abarbeitung Flaschenhälse entstehen und 
wie werden Sie umgangen bzw. bekämpft. Welchen Einfluss hat der Programmierer auf die Pipeline bzw. welche Schritte kann er selber
implementieren und welche Schritte werden rein von der Hardware übernommen und können nicht von ihm modifiziert werden. 
Diese Arbeit macht den Aufbau einer modernen Rendering-Pipeline verständlich und vermittelt den Begriff Rasterisierung
Zusätzlich wird es bei dieser Abhandlung, dank des stetigen technologischen Fortschritts, ein Ausblick auf zukünftige Entwicklungen
und Neuerungen gegeben, die zukünftig moderne Rendering-Pipelines beherrschen wird.
%% ==============================

\chapter{Einleitung}
\label{ch:Introduction}

Wollen wir mit einer Anwendung ein Objekt, z.B. eine Teekanne, auf einem Computer darstellen, so liegt das Objekt zuerst in Form
von vielen Eckpunkten(Dreiecken) in der Anwendung vor. Die Eckpunkte gehen zuerst durch den Vertex-Shader und durchlaufen
dort Transformationen. Sind diese aus der Vertex Shader - Einheit werden Sie zu Primitiven(meist Dreiecken) zusammengefasst.
Der anschließende Tessalation-Shader nimmt die Primitive entgegen und kann Sie weiterhin unterteilen.
Die Primitive werden von dem Tessellation- zum Geometry Shader durchgereicht, welcher diese vervielfachen, entfernen oder 
beliebig verändern kann. Darauf folgt das Clipping, worauf der Entwickler keinen Einfluss hat und nicht relevante Szenengeometrie
entfernt. Nun kommt die Rasterisierung zum Einsatz, welche unsere 3D-Objekte auf den 2D-Schirm bringt und uns
Fragmente(Bildschirmpixel) liefert. Auf diesen Fragmenten lassen sich eine Vielzahl von Fragmentoperationen ausführen
Die heutige moderne Rendering-Pipeline zeichnet sich durch seine gesteigerte Flexibilität gegenüber der Älteren, welche viele 
feste Funktionen beinhaltete, aus. Und dieser Trend scheint nicht abzureißen. Auch die heutigen rasanten technologischen Fortschritte, 
z.B. bei der Hardware, erlauben den Einsatz von Technologien, welche früher nicht eingesetzt werden konnten, 
und geben dem Entwickler immer mehr Freiheiten mit deren Benutzung. So feiert derzeit das Raytracing innerhalb der Echtzeitcomputergrafik
einen Siegeszug und wackelt am Thron der bisherigen sehr effizienten Rasterisierung.

%% ==============

\chapter{Moderne Rendering-Pipeline}

    \section{Anwendung}

    
    Zu rendernde Objekte werden zunächst von der Anwendung zur Grafikkarte geschickt. Dabei liegen die Daten über ein
    Objekt beispielhaft im OBJ-Dateiformat vor. Die Informationen über einen Vertex, das sind die Position,
    Normale und Texturkoordinate sind für Berechnungen der nächsten Stufe, des Vertex Shaders, wichtig.
    Des Weiteren sind Flächeninformationen, die für das Primitive-Assembly von Bedeutung sind, und ein Material definiert.
    In der Anwendung können Informationen über ein Objekt geupdatet werden, z.B. bei Kollisionen von Objekten bei denen sich 
    Positionen verändern, 
    
    \begin{figure}[htb]
        \centering
        \begin{minipage}[t]{0.45\linewidth}
            \centering
            \includegraphics[width=.75\linewidth]{Bilder/MaterialDefs.PNG}
            \caption{Definition beispielhaftes Material}
        \end{minipage}
        \hfill
        \begin{minipage}[t]{0.45\linewidth}
            \centering
            \includegraphics[width=\linewidth]{Bilder/ObjectData.png}
            \caption{Vertex Daten im OBJ-Dateiformat}
        \end{minipage}
    \end{figure}

    \section{Geometrie}

        \subsection{Vertex Shader}

            \begin{figure}[h]
                \centering
                \def\svgwidth{\columnwidth}
                \import{Bilder/}{VertexShader.pdf_tex}
                \label{Vertex Shader}
                \caption{Funktionsweise Vertex Shader}
            \end{figure}

        Hier arbeiten wir komplett in Objektkoordinaten.

        \subsection{Primitive Assembly}

        \subsection{Tessellation}

            \begin{figure}[h]
                \centering
                \def\svgwidth{\columnwidth}
                \import{Bilder/}{Tessellation.pdf_tex}
                \label{Tessellation Shader}
                \caption{Funktionsweise Tessellation Shader}
            \end{figure}

        Hinzufügen neuer Vertices.

        \subsection{Geometry Shader}
            
            \begin{figure}[h]
                \centering
                \def\svgwidth{\columnwidth}
                \import{Bilder/}{GeometryShader.pdf_tex}
                \label{Geometry Shader}
                \caption{Funktionsweise Geometry Shader}
            \end{figure}

        \subsection{Clipping}

        Um Objekte bzw. Objektausschnitte, welche außerhalb des Sichtfensters liegen, für die Bildsynthese zu verwerfen kommt nun das Abschneiden(englisch = "clipping").
        Algorithmus von Sutherland-Hodgman.
        Wir gehen vom Clip-Space zum Window-Space

        \subsection{Viewport Transform}

    \section{Rasterization}

    In der vorherigen Geometriestufe wurde einem klar, dass wir ein Objekt nach dem Anderen betrachten (Object-ordered Rendering) 
    
    \section{Fragment Shader}

    \section{Per Fragment Operations}

        \subsection{Multisample Fragment Ops}
    
        \subsection{Stencil Test}

        \subsection{Occlusion Query}
    
        \subsection{Blending}

        \subsection{Logical Operations}

    \section{Framebuffer und Buffer Objekte}

    \section{GPU Memory}

    \section{Compute Shader}
    
    \begin{figure}[h]
        \centering
        \def\svgwidth{\columnwidth}
        \import{Bilder/}{ComputeShader.pdf_tex}
        \label{Compute Shader}
        \caption{Funktionsweise Compute Shader}
    \end{figure}

    Mit der rasant steigenden Leistung heutiger Grafikhardware stieg auch der Wunsch beim Anwender nach mehr Rechenleistung.
    Parallesisierbare Arbeit wird in Threadgroups eingeteilt. Threads innerhalb einer Gruppe laufen gleichzeitig, wohingegen
    die Threadgruppen untereinander dies nicht müssen.

\chapter{Unterschied moderne und klassische Rendering-Pipeline}

    \section{Freie Programmierung oder reines Konfigurieren}
        
        \begin{figure}[htb]
            \centering
            \begin{minipage}[t]{0.45\linewidth}
                \centering
                \includegraphics[width=.75\linewidth]{Bilder/MaterialDefs.PNG}
                \caption{Definition beispielhaftes Material}
            \end{minipage}
            \hfill
            \begin{minipage}[t]{0.45\linewidth}
                \centering
                \includegraphics[width=\linewidth]{Bilder/ObjectData.png}
                \caption{OpenGL <= }
            \end{minipage}
        \end{figure}

    \section{Vertex Arrays, Index Buffers, ..}

%% ===========================
\chapter{Ausblick}

\section{Raytracing Unterstützung}

Moderne Ansätze gehen von der objektbasierten (siehe Rasterisierung) zu der Image-ordered Bilderstellung über.
Hiermit werden nicht nur Primär- sondern auch Sekundärstrahlen(etc.) betrachtet und somit unter Anderem Schatten und Spiegelungen
erreicht ohne dafür spezielle Techniken verwenden zu müssen (siehe Rasterisierung). 

\section{Task-/Mesh Shaders}

Allgemein lässt sich an dieser neuen Technik der Trend von fixen Vorgängen innerhalb der Pipeline zu mehr
flexibleren wiedererkennen. So kann der Task Shader mit der Control Shader Einheit der bisherigen Tessellation verglichen werden. 
Jedoch arbeiten wir hier mit mehreren Threads und mit frei wählbaren In- und Output! Mehr Flexibilität ist 
die Devise.
Anstatt einzelne Dreiecke einzeln zu berechnen wie in der bisherigen Pipeline können wir mehrere gleichzeitig
bearbeiten in sogenannten parallelen Thread-Gruppen. Hier wird also nichts anderes als das Modell von Compute Shader
genommen und auf die Grafikpipeline angewandt. Vorallem bei komplexen Szenen mit vielen Millionen Dreicken 
verspricht man sich eine Entlastung der CPU. Durch diesen Aufbau können wir bereits im Vorfeld viele Dreiecke vom Rendern 
ausschließen. \par
Dabei wird ein komplexes Mesh in einzelne "Meshlets" zerlegt, welche wiederrum von Mesh Shadern behandelt werden.

\includegraphics[width=1.\textwidth]{Bilder/meshlets_pipeline.png}
\label{ch:Content1:sec:Section1}
%% ===========================


%% content.tex
%%
