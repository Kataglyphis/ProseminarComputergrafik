%% content.tex
%%

%% ==============================

\chapter{Abstract}

In unser heutigen hoch technologisierten Welt steigt stetig und rasant die Leistungsfähigkeit moderner Grafikhardware.
Um heutzutage Grafik auf einem modernen Computer darzustellen sind mittlerweile eine Vielzahl von Zwischenschritten nötig.
Diese Arbeit beschäftigt sich um die einzelnen Stufen dieser Kette, deren jeweilige Aufgabe, ihren Datentransfer untereinander,
ihre Reihenfolge sowie ihren Arbeitskontext. Beim Arbeitskontext werden unter anderem die unterschiedlichen Koordinatensysteme untersucht. 
Dabei soll nicht nur konkret auf die Arbeitsweise der einzelnen Stufe eingegangen werden, sondern auch im Speziellen auf die Zusammenarbeit und Kommunikation. 
Exemplarische Fragestellungen die behandelt werden sind Folgende: Können in dieser Art der Abarbeitung Flaschenhälse entstehen und 
wie werden Sie umgangen bzw. bekämpft. Welchen Einfluss hat der Programmierer auf die Pipeline bzw. welche Schritte kann er selber
implementieren und welche Schritte werden rein von der Hardware übernommen und können nicht von ihm modifiziert werden. 
Diese Arbeit macht den Aufbau einer modernen Rendering-Pipeline verständlich und vermittelt den Begriff Rasterisierung
Zusätzlich wird es bei dieser Abhandlung, dank des stetigen technologischen Fortschritts, ein Ausblick auf zukünftige Entwicklungen
und Neuerungen gegeben, die zukünftig moderne Rendering-Pipelines beherrschen wird.
%% ==============================

\chapter{Einleitung}
\label{ch:Introduction}

%% ==============

\chapter{Moderne Rendering-Pipeline}

    \section{Anwendung}\dots

    In der Anwendung werden die zu zeichnenden Objekte 

    \section{Geometrie}\dots

        \subsection{Vertex Shader}\dots

        Hier arbeiten wir komplett in Objektkoordinaten.

        \subsection{Primitive Assembly}\dots 

        \subsection{Tessellation}\dots 

        Hinzufügen neuer Vertices.

        \subsection{Geometry Shader}\dots 
            
        \subsection{Clipping}\dots

        Um Objekte bzw. Objektausschnitte, welche außerhalb des Sichtfensters liegen, für die Bildsynthese zu verwerfen kommt nun das Abschneiden(englisch = "clipping").
        Algorithmus von Sutherland-Hodgman.
        Wir gehen vom Clip-Space zum Window-Space

        \subsection{Viewport Transform}\dots

    \section{Rasterization}\dots

    In der vorherigen Geometriestufe wurde einem klar, dass wir ein Objekt nach dem Anderen betrachten (Object-ordered Rendering) 
    
    \section{Fragment Shader}\dots

    \section{Per Fragment Operations}\dots

        \subsection{Multisample Fragment Ops}\dots
    
        \subsection{Stencil Test}\dots

        \subsection{Occlusion Query}\dots
    
        \subsection{Blending}\dots

        \subsection{Logical Operations}\dots

    \section{Framebuffer und Buffer Objekte}\dots

    \section{GPU Memory}\dots

    \section{Compute Shader}\dots

\chapter{Unterschied moderne und klassische Rendering-Pipeline}

    \section{Freie Programmierung oder reines Konfigurieren}\dots

    \section{Vertex Arrays, Index Buffers, ..}\dots

%% ===========================
\chapter{Ausblick}

\section{Raytracing Unterstützung}\dots

Moderne Ansätze gehen von der objektbasierten (siehe Rasterisierung) zu der Image-ordered Bilderstellung über.
Hiermit werden nicht nur Primär- sondern auch Sekundärstrahlen(etc.) betrachtet und somit unter Anderem Schatten und Spiegelungen
erreicht ohne dafür spezielle Techniken verwenden zu müssen (siehe Rasterisierung). 

\label{ch:Content1:sec:Section1}
%% ===========================


%% content.tex
%%

\dots
